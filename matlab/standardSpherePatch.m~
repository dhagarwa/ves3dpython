function p = standardSpherePatch(m, n, numPatch, R)


p = Patch(m, n, R, numPatch, []);

    if numPatch==1 
        p.r = [R*sin(p.u).*cos(p.v), R*sin(p.u).*sin(p.v), R*cos(p.u)];
        
    elseif numPatch==2
        %p.r = [R*sin(p.u).*cos(p.v), -R*sin(p.u).*sin(p.v), R*cos(p.u)];
        %before patch u-v direction alignment 
        
        p.r = [-R*sin(p.u).*cos(p.v), -R*sin(p.u).*sin(p.v), R*cos(p.u)];
    elseif numPatch==5
        p.r = [R*sin(p.u).*cos(p.v), R*cos(p.u), R*sin(p.u).*sin(p.v)]; %u 0 to pi, v 0 to pi
        %p.r = [R*sin(p.u).*cos(p.v), R*sin(p.u).*sin(p.v), R*cos(p.u)]; % u 0 to pi/2 , v 0 to 2*pi, patch is to be extended by mirror image
    elseif numPatch==6
        
        p.r = [R*sin(p.u).*cos(p.v), R*sin(p.u).*sin(p.v), R*cos(p.u)]; % u pi/2 to pi, v 0 to 2*pi, patch is to be extended by mirror image

    elseif numPatch==3
        %p.r = [R*sin(p.u).*sin(p.v), R*sin(p.u).*cos(p.v), R*cos(p.u)];
        p.r = [R*sin(p.u).*sin(p.v), -R*sin(p.u).*cos(p.v), R*cos(p.u)];

    elseif numPatch==4
        %p.r = [-R*sin(p.u).*sin(p.v), R*sin(p.u).*cos(p.v), R*cos(p.u)];
        p.r = [-R*sin(p.u).*sin(p.v), R*sin(p.u).*cos(p.v), R*cos(p.u)];
    end

    
p = p.update();    %updating x, y, z from r and pou
p.J = abs(R^2*sin(p.u)); %Setting jacobian


end


